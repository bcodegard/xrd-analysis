"""
load a branch from a root file, cut, transform, and fit
optionally output fit results as csv and/or figure
"""

__author__ = "Brunel Odegard"
__version__ = "0.1"


import os
import sys
import math
import argparse

import numpy as np
import matplotlib.pyplot as plt

import utils.cli     as cli
import utils.data    as data
import utils.model   as model
import utils.fileio  as fileio
import utils.display as display
import utils.expression as expr




# todo: put this in a config file instead of code
ROOT_FILE_DIR = "../xrd-analysis/data/root/scintillator/Run{}.root"


# utility functions

def inrange(arr, lo, hi):
	pieces = []
	if lo not in [None, -np.inf]:
		pieces.append(arr>lo)
	if hi not in [None, np.inf]:
		pieces.append(arr<hi)
	if len(pieces) == 1:
		return pieces[0]
	else:
		return np.logical_and(*pieces)

def edges_lin(xmin, xmax, nbins):
	return np.linspace(xmin, xmax, nbins+1)

def edges_log(xmin, xmax, nbins):
	return np.logspace(math.log(xmin,10), math.log(xmax,10), nbins+1)

def edges_symlog(xmin, xmax, nbins, l=1):
	slxmin = symlog(xmin, l)
	slxmax = symlog(xmax, l)
	y = np.linspace(slxmin, slxmax, nbins+1)
	return isymlog(y, l)

def symlog(x, l):

	isscalar = np.isscalar(x)
	x = np.atleast_1d(x)

	y = np.zeros(x.shape)
	
	ftr_pos = (x >  l)
	ftr_neg = (x < -l)
	ftr_lin = np.logical_not(np.logical_or(ftr_pos,ftr_neg))
	
	b=math.e/l
	y[ftr_pos] =  np.log( b*x[ftr_pos])
	y[ftr_neg] = -np.log(-b*x[ftr_neg])
	y[ftr_lin] = x[ftr_lin] * (b/math.e)
	
	if isscalar:
		return y[0]
	else:
		return y

def isymlog(y, l):
	
	isscalar = np.isscalar(y)
	y = np.atleast_1d(y)

	x = np.zeros(y.shape)

	ftr_pos = (y >  1)
	ftr_neg = (y < -1)
	ftr_lin = np.logical_not(np.logical_or(ftr_pos,ftr_neg))

	x[ftr_pos] =  np.exp( y[ftr_pos] - 1)
	x[ftr_neg] = -np.exp(-y[ftr_neg] - 1)
	x[ftr_lin] = y[ftr_lin]

	if isscalar:
		return x[0] * l
	else:
		return x * l




def procure_data(args):
	"""Load branches from specified file as needed to calculate
	all fit and cut expressions. Then apply cuts and binning, and
	return only the processed fit data."""

	# set of branches needed to evaluate all fits, cuts, defs, and xfs
	branches_needed = set()

	# compile expressions and update branches_needed
	fn_fits = []
	for fit in args.fits:
		# skip fits where the first entry is None. This happens when
		# the positional argument is not specified, so handling this
		# case lets us supply all fits via --fit if desired.
		if fit[0] is None:
			continue
		fn = expr.check_and_compile(fit[0])
		fn_fits.append(fn)
		branches_needed |= fn.kwargnames

	# copy at this point to capture branches needed for fit expressions
	branches_needed_fit = branches_needed.copy()
	
	fn_cuts = []
	for cut in args.cuts:
		fn = expr.check_and_compile(cut[0])
		fn_cuts.append(fn)
		branches_needed |= fn.kwargnames

	# copy branches_needed at this point to capture which are needed
	# explicitly for fits and cuts
	branches_fit_and_cut = branches_needed.copy()
	
	fn_defs = []
	for def_ in args.defs:
		fn = expr.check_and_compile(def_[1])
		fn_defs.append(fn)
		branches_needed |= fn.kwargnames
	
	fn_xfs = []
	for xf in args.xfs:
		raise Exception("xfs not implemented yet")
		fn = expr.check_and_compile(xf[1])
		fn_xfs.append(fn)
		branches_needed |= fn.kwargnames

	# load branches from specified root file, allowing for missing
	# branches. missing branches must be generated by one of the
	# defs or xfs included.
	root_file = args.run if os.sep in args.run else ROOT_FILE_DIR.format(args.run)
	branches = fileio.load_branches(root_file, branches_needed)

	# initialize the branch manager instance with the resulting branches
	bm = data.BranchManager(branches, export_copies=False, import_copies=False)

	# apply scaler convolution
	if args.rectify_scalers:
		if any(_.startswith("scaler_") for _ in bm.keys):
			bm.bud(data.rectify_scaler(), overwrite=True)

	# apply timestamp fix and localization
	if any(_.startswith("timestamp_") for _ in bm.keys):
		bm.bud(data.fix_monotonic_timestamp(), overwrite=True)
		if args.localize_timestamps:
			bm.bud(data.localize_timestamp(), overwrite=True)

	# process defs and xfs to create new branches
	# todo: current implementation is slightly inefficient. defs and xfs
	# are evaluated before applying any cuts, resulting in excess
	# computation in the case where cuts do not depend on defs or xfs.
	# an implementation which applies each cut as soon as it is able to,
	# and prioritizes defs and xfs which enable cuts, would be faster.
	fn_defs_remain = [True for _ in fn_defs]
	fn_xfs_remain  = [True for _ in fn_xfs]
	n_remaining = len(fn_defs) + len(fn_xfs)
	while n_remaining:

		for i,remain in enumerate(fn_defs_remain):
			if remain and fn_defs[i].kwargnames.issubset(bm.keys):

				this_name = args.defs[i][0]
				this_fn = fn_defs[i]

				bm.bud(
					lambda man:{this_name:this_fn(**{_:man[_] for _ in this_fn.kwargnames})}
				)

				fn_defs_remain[i] = False

		# for i,remain in enumerate(fn_xfs_remain):
		# 	if remain and fn_xfs[i].kwargnames.issubset(bm.keys):
		# 		bm.bud()
		# 		fn_xfs_remain[i] = False

		# if we have all branches needed for fits and cuts, there's
		# no need to keep evaluating defs and xfs
		if branches_fit_and_cut.issubset(bm.keys):
			break

		n_remaining_now = sum(fn_defs_remain) + sum(fn_xfs_remain)
		if n_remaining_now == n_remaining:
			print("could not evaluate all definititions and transformations")
			print("missing one or more variables for completion")
			sys.exit(1)
		n_remaining = n_remaining_now

	# process cuts
	masks = []
	for icut,fn in enumerate(fn_cuts):
		this_cut = args.cuts[icut]

		# no bounds specified: boolean expression
		if (this_cut[1] is None) and (this_cut[2] is None):
			masks.append(lambda man:fn(**{_:man[_] for _ in fn.kwargnames}))

		# at least one boundspecified: lo<expression<hi
		else:
			masks.append(lambda man:inrange(fn(**{_:man[_] for _ in fn.kwargnames}),this_cut[1],this_cut[2]))

	# apply cuts
	if masks:
		data_fit_raw = bm.mask(
			data.mask_all(*masks),
			branches_needed_fit,
			apply_mask = False,
		)
	else:
		data_fit_raw = {_:bm[_] for _ in branches_needed_fit}


	# data_fit_raw are all the branches that show up in the expression
	# for at least one fit. to get the fit data, we have still have to
	# evaluate the expressions.
	fit_data = []
	for fn in fn_fits:
		fit_data.append(fn(**{_:data_fit_raw[_] for _ in fn.kwargnames}))

	fit_counts = []
	fit_edges = []
	for i,fit in enumerate(args.fits):

		this_data = fit_data[i]
		lo = this_data.min() if fit[1] in [None,-np.inf] else fit[1]
		hi = this_data.max() if fit[2] in [None, np.inf] else fit[2]
		nbins = 100 if fit[3] is None else fit[3]

		if fit[4].startswith("li"):
			this_edges = edges_lin(lo,hi,fit[3])
		elif fit[4].startswith("lo"):
			this_edges = edges_log(lo,hi,fit[3])
		elif fit[4].startswith("s"):
			this_edges = edges_symlog(lo,hi,fit[3])

		this_counts, _ = np.histogram(this_data, this_edges)
		fit_counts.append(this_counts)
		fit_edges.append(this_edges)

		# testing fit data results: just show plots
		plt.step(
			(this_edges[1:]+this_edges[:-1])*0.5,
			this_counts,
			where='mid',
			label=fit[0],
		)
	plt.legend()
	plt.yscale("log")
	if fit[4].startswith("lo"):plt.xscale("log")
	plt.show()



	sys.exit(0)

	...
	return fit_data_binned


def main(args):
	print(args)

	# load, process, cut, and bin data into form ready for fitting
	fit_data = procure_data(args)



# def isname(string):
# 	"""whether string is entirely alphanumeric + underscores"""
# 	return string.replace("_","").isalnum()

# def compile_if_expression(string):
# 	""""""
# 	if isname(string):
# 		return lambda **items:items[string]
# 	else:
# 		return expr.check_and_compile(string)

if __name__ == '__main__':

	parser = argparse.ArgumentParser(
		description="fit a model to a binned branch, optionally transforming and cutting",
		)

	# version
	parser.add_argument("--version",action="version",version="%(prog)s {}".format(__version__))


	# data arguments
	parser.add_argument("run",type=str,help="file location, name, or number")

	# allow fit data specification to be supplied by positional argument
	# representing the first dataset to be fit, and further datasets
	# to be specified using --fit 
	callables_fit = (str, float, float, int, str)
	defaults_fit = (None, -np.inf, np.inf, 0, "lin")
	parser.add_argument(
		"fits",
		type=str,
		nargs="*",
		action=cli.MergeAppendAction,
		const=(callables_fit, defaults_fit),
		default=[],
		help="expression min=-inf max=inf nbins=auto scale=lin(,log,symlog)",
	)
	parser.add_argument(
		"--fit","--f",
		type=str,
		nargs="+",
		dest="fits",
		action=cli.MergeAppendAction,
		const=(callables_fit, defaults_fit),
		default=[],
		help="same as fit, used to specify multiple while allowing positional specification for first",
	)
	
	# cuts
	parser.add_argument(
		"--cut","--c",
		type=str,
		nargs="+",
		dest="cuts",
		action=cli.MergeAppendAction,
		const=((str,float,float),(None,None,None)),
		default=[],
		help="cut on expression. logical_all applied if multiple cuts.",
	)
	
	# expression definitions
	parser.add_argument(
		"--def", "--d",
		type=str,
		nargs=2,
		dest="defs",
		action=cli.MergeAppendAction,
		const=((str,str),(None,None)),
		default=[],
		help="""define a new branch using an expression.
		Usage --def new_branch_name expression""",
	)

	# models
	parser.add_argument(
		"--xf",
		type=str,
		nargs="+",
		dest="xfs",
		action=cli.MergeAppendAction,
		const=((str,str,str,int),(None,None,None,None)),
		default=[],
		help="""define a new branch using a transformation stored in a file.
		Usage --xf new_branch_name expression file model_id=any""",
	)

	# scaler convolution
	parser.add_argument(
		"--no-rectify-scalers","--nrs",
		dest="rectify_scalers",
		action="store_const",
		const=0,
		default=12,
		help="don't rectify scalers",
	)
	parser.add_argument(
		"--rectify-scalers","--rs",
		dest="rectify_scalers",
		type=int,
		default=12,
		help="rectify scalers. Usage --rs kernel_size=12",
	)

	# timestamp localization
	parser.add_argument(
		"--no-timestamp-local","--ntl",
		action="store_false",
		dest="localize_timestamps",
		help="don't localize timestamps",
	)

	# splits
	# todo: implement this


	# fitting arguments
	...



	args = parser.parse_args()

	# remove fit args with empty expression
	args.fits = [_ for _ in args.fits if _[0] is not None]

	main(args)